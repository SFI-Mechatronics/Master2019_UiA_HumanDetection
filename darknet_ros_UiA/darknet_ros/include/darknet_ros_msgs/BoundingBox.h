// Generated by gencpp from file darknet_ros_msgs/BoundingBox.msg
// DO NOT EDIT!


#ifndef DARKNET_ROS_MSGS_MESSAGE_BOUNDINGBOX_H
#define DARKNET_ROS_MSGS_MESSAGE_BOUNDINGBOX_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace darknet_ros_msgs
{
template <class ContainerAllocator>
struct BoundingBox_
{
  typedef BoundingBox_<ContainerAllocator> Type;

  BoundingBox_()
    : Class()
    , probability(0.0)
    , xmin(0)
    , ymin(0)
    , xmax(0)
    , ymax(0)
    , X(0.0)
    , Y(0.0)
    , Z(0.0)
    , Xg(0.0)
    , Yg(0.0)
    , Zg(0.0)
    , Ymax(0.0)
    , Ymin(0.0)
    , Uc(0.0)
    , Vc(0.0)
    , Uir(0.0)
    , Vir(0.0)
    , Virmax(0.0)
    , Virmin(0.0)
    , num(0)
    , Invalid(false)  {
    }
  BoundingBox_(const ContainerAllocator& _alloc)
    : Class(_alloc)
    , probability(0.0)
    , xmin(0)
    , ymin(0)
    , xmax(0)
    , ymax(0)
    , X(0.0)
    , Y(0.0)
    , Z(0.0)
    , Xg(0.0)
    , Yg(0.0)
    , Zg(0.0)
    , Ymax(0.0)
    , Ymin(0.0)
    , Uc(0.0)
    , Vc(0.0)
    , Uir(0.0)
    , Vir(0.0)
    , Virmax(0.0)
    , Virmin(0.0)
    , num(0)
    , Invalid(false)  {
  (void)_alloc;
    }



   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _Class_type;
  _Class_type Class;

   typedef double _probability_type;
  _probability_type probability;

   typedef int64_t _xmin_type;
  _xmin_type xmin;

   typedef int64_t _ymin_type;
  _ymin_type ymin;

   typedef int64_t _xmax_type;
  _xmax_type xmax;

   typedef int64_t _ymax_type;
  _ymax_type ymax;

   typedef float _X_type;
  _X_type X;

   typedef float _Y_type;
  _Y_type Y;

   typedef float _Z_type;
  _Z_type Z;

   typedef float _Xg_type;
  _Xg_type Xg;

   typedef float _Yg_type;
  _Yg_type Yg;

   typedef float _Zg_type;
  _Zg_type Zg;

   typedef float _Ymax_type;
  _Ymax_type Ymax;

   typedef float _Ymin_type;
  _Ymin_type Ymin;

   typedef float _Uc_type;
  _Uc_type Uc;

   typedef float _Vc_type;
  _Vc_type Vc;

   typedef float _Uir_type;
  _Uir_type Uir;

   typedef float _Vir_type;
  _Vir_type Vir;

   typedef float _Virmax_type;
  _Virmax_type Virmax;

   typedef float _Virmin_type;
  _Virmin_type Virmin;

   typedef int8_t _num_type;
  _num_type num;

   typedef uint8_t _Invalid_type;
  _Invalid_type Invalid;





  typedef boost::shared_ptr< ::darknet_ros_msgs::BoundingBox_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::darknet_ros_msgs::BoundingBox_<ContainerAllocator> const> ConstPtr;

}; // struct BoundingBox_

typedef ::darknet_ros_msgs::BoundingBox_<std::allocator<void> > BoundingBox;

typedef boost::shared_ptr< ::darknet_ros_msgs::BoundingBox > BoundingBoxPtr;
typedef boost::shared_ptr< ::darknet_ros_msgs::BoundingBox const> BoundingBoxConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::darknet_ros_msgs::BoundingBox_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::darknet_ros_msgs::BoundingBox_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace darknet_ros_msgs

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': False}
// {'sensor_msgs': ['/opt/ros/kinetic/share/sensor_msgs/cmake/../msg'], 'darknet_ros_msgs': ['/home/nvidia/catkin_ws/src/Master2019_UiA_HumanDetection/darknet_ros_UiA/darknet_ros_msgs/msg', '/home/nvidia/catkin_ws/devel/share/darknet_ros_msgs/msg'], 'actionlib_msgs': ['/opt/ros/kinetic/share/actionlib_msgs/cmake/../msg'], 'geometry_msgs': ['/opt/ros/kinetic/share/geometry_msgs/cmake/../msg'], 'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::darknet_ros_msgs::BoundingBox_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::darknet_ros_msgs::BoundingBox_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::darknet_ros_msgs::BoundingBox_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::darknet_ros_msgs::BoundingBox_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::darknet_ros_msgs::BoundingBox_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::darknet_ros_msgs::BoundingBox_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::darknet_ros_msgs::BoundingBox_<ContainerAllocator> >
{
  static const char* value()
  {
    return "6b54ff3d234b2c930f2308f95cd3aeb7";
  }

  static const char* value(const ::darknet_ros_msgs::BoundingBox_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x6b54ff3d234b2c93ULL;
  static const uint64_t static_value2 = 0x0f2308f95cd3aeb7ULL;
};

template<class ContainerAllocator>
struct DataType< ::darknet_ros_msgs::BoundingBox_<ContainerAllocator> >
{
  static const char* value()
  {
    return "darknet_ros_msgs/BoundingBox";
  }

  static const char* value(const ::darknet_ros_msgs::BoundingBox_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::darknet_ros_msgs::BoundingBox_<ContainerAllocator> >
{
  static const char* value()
  {
    return "string Class\n\
float64 probability\n\
int64 xmin\n\
int64 ymin\n\
int64 xmax\n\
int64 ymax\n\
float32 X\n\
float32 Y\n\
float32 Z\n\
float32 Xg\n\
float32 Yg\n\
float32 Zg\n\
float32 Ymax\n\
float32 Ymin\n\
float32 Uc\n\
float32 Vc\n\
float32 Uir\n\
float32 Vir\n\
float32 Virmax\n\
float32 Virmin\n\
int8 num\n\
bool Invalid\n\
";
  }

  static const char* value(const ::darknet_ros_msgs::BoundingBox_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::darknet_ros_msgs::BoundingBox_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.Class);
      stream.next(m.probability);
      stream.next(m.xmin);
      stream.next(m.ymin);
      stream.next(m.xmax);
      stream.next(m.ymax);
      stream.next(m.X);
      stream.next(m.Y);
      stream.next(m.Z);
      stream.next(m.Xg);
      stream.next(m.Yg);
      stream.next(m.Zg);
      stream.next(m.Ymax);
      stream.next(m.Ymin);
      stream.next(m.Uc);
      stream.next(m.Vc);
      stream.next(m.Uir);
      stream.next(m.Vir);
      stream.next(m.Virmax);
      stream.next(m.Virmin);
      stream.next(m.num);
      stream.next(m.Invalid);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct BoundingBox_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::darknet_ros_msgs::BoundingBox_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::darknet_ros_msgs::BoundingBox_<ContainerAllocator>& v)
  {
    s << indent << "Class: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.Class);
    s << indent << "probability: ";
    Printer<double>::stream(s, indent + "  ", v.probability);
    s << indent << "xmin: ";
    Printer<int64_t>::stream(s, indent + "  ", v.xmin);
    s << indent << "ymin: ";
    Printer<int64_t>::stream(s, indent + "  ", v.ymin);
    s << indent << "xmax: ";
    Printer<int64_t>::stream(s, indent + "  ", v.xmax);
    s << indent << "ymax: ";
    Printer<int64_t>::stream(s, indent + "  ", v.ymax);
    s << indent << "X: ";
    Printer<float>::stream(s, indent + "  ", v.X);
    s << indent << "Y: ";
    Printer<float>::stream(s, indent + "  ", v.Y);
    s << indent << "Z: ";
    Printer<float>::stream(s, indent + "  ", v.Z);
    s << indent << "Xg: ";
    Printer<float>::stream(s, indent + "  ", v.Xg);
    s << indent << "Yg: ";
    Printer<float>::stream(s, indent + "  ", v.Yg);
    s << indent << "Zg: ";
    Printer<float>::stream(s, indent + "  ", v.Zg);
    s << indent << "Ymax: ";
    Printer<float>::stream(s, indent + "  ", v.Ymax);
    s << indent << "Ymin: ";
    Printer<float>::stream(s, indent + "  ", v.Ymin);
    s << indent << "Uc: ";
    Printer<float>::stream(s, indent + "  ", v.Uc);
    s << indent << "Vc: ";
    Printer<float>::stream(s, indent + "  ", v.Vc);
    s << indent << "Uir: ";
    Printer<float>::stream(s, indent + "  ", v.Uir);
    s << indent << "Vir: ";
    Printer<float>::stream(s, indent + "  ", v.Vir);
    s << indent << "Virmax: ";
    Printer<float>::stream(s, indent + "  ", v.Virmax);
    s << indent << "Virmin: ";
    Printer<float>::stream(s, indent + "  ", v.Virmin);
    s << indent << "num: ";
    Printer<int8_t>::stream(s, indent + "  ", v.num);
    s << indent << "Invalid: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Invalid);
  }
};

} // namespace message_operations
} // namespace ros

#endif // DARKNET_ROS_MSGS_MESSAGE_BOUNDINGBOX_H
